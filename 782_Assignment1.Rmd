---
title: "Assignment_1"
author: "Shuo Mao 437681258"
date: "2024-07-23"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Task 1:
## Re-create the following sequences using R without the use of c() and explicit values. Hint: making use of the help files will sometimes help a lot.

(a): 

`(i) [1] -4 4 -4 4 -3 3 -3 2 -2 1`

```{r}
{positive_numbers = rep(4:1, 4:1);#creating numbers
alternating_sequence = positive_numbers * rep(c(-1, 1),#using circle to re-assign their postie or negative sign to it
                                              length.out = length(positive_numbers))}
print(alternating_sequence)
```


`(ii) [1] 1 22 333 4444 55555 666666 7777777 88888888`


```{r}
# using function to create repeated number with no space, then adding space between each repeated numbers
formatted_sequence <- paste(sapply(1:8, function(x) paste(rep(x, x), collapse = ""))# will generate number such as: 1, 22, 333 ....
                            , collapse = " ") # combine those number and re-format it. 

# Print the formatted sequence
cat(formatted_sequence)
```


`(iii) [1] "z" "Y" "x" "W" "v" "U" "t" "S" "r" "Q" "p" "O" "n" "M" "l" "K" "j" "I" "h" "G" [21] "f" "E" "d" "C" "b" "A"`


```{r}

lowercase <- rev(letters)  # "z" to "a"
uppercase <- rev(LETTERS)  # "Z" to "A"

#combine uppercase and lowercase alternatively 
combined <- c(rbind(lowercase[seq(1, 26, 2)], uppercase[seq(2, 26, 2)]))

# Print the combined sequence
print(combined)
```


`(iv) [1] "1^1=1" "2^2=4" "3^3=27" "4^4=256" "5^5=3125" [6] "6^6=46656" "7^7=823543" "8^8=16777216"`



```{r}
# Calculate the power results
{exponents <- 1:8;results <- paste(exponents, "^", exponents, "=", exponents^exponents)}
print(results)
```


`(v) [1] "jan1" "feb2" "mar3" "apr4" "may5" "jun6" "jul7" "aug8" "sep9" "oct10" [11] "nov11" "dec12"`


```{r}
# Create the vector of month abbreviations and corresponding numbers, then Combine the month abbreviations with the numbers
{months <- tolower(month.abb);numbers <- 1:12;result <- paste(months, numbers, sep = "")}
# Print the result
print(result)
```



(b): find and write down six different ways to assign a variable x the value 8

1: using '=' 
```{r}
x = 8 
print(x)
```
2: using '->'
```{r}
8 -> x
print(x)
```

3: using '<-'
```{r}
x <- 8
print(x)
```

4: using assign function
```{r}
assign("x", 8)
print(x)
```

5: using list function 

```{r}
x <<- 8
print(x)
```

6: using c function 

```{r}
x <- c(9,8,1,4)[2]
print(x)

eval(x <- 8)
x
```
## (c) We know that ex = ∑∞ i=0 xi/i!. Approximate this by A(k; x) = ∑k i=0 xi/i! for finite k. Find the value k such that A(k; 1) does not differ by exp(1) on your machine. 


```{r}
# Compute Euler's number
e <- exp(1)

# Initialize variables
k <- 0
approximation <- 0
tolerance <- .Machine$double.eps *2 # Machine precision (default tolerance)

# Loop to find the smallest k
repeat {
  # Update the approximation of A(k; 1)
  approximation <- approximation + 1 / factorial(k)
  
  # Check if the approximation is within the tolerance
  if (abs(approximation - e) <= tolerance) {
    break
  }
  
  # Increment k
  k <- k + 1
}

# Output the result
cat(sprintf("The smallest k such that A(k; 1) approximates exp(1) within machine precision is: %d\n", k))

```

# Task 2:Consider the data frame xs.nz in VGAMdata. Based on this cross-sectional study, use R expressions (not your eyes or my eyes) to find the values below (and show the values only, nothing else). Don’t use any explicit loop or anything equivalent. Ignore (delete) any cases with NAs in the relevant variables. Your code should be elegant and readable, etc

```{r}
# install vgamdata if not exist
if (!requireNamespace("VGAMdata", quietly = TRUE)) {
    install.packages("VGAMdata")
}
library(VGAMdata)
#str(xs.nz)
xs.nz <- na.omit(xs.nz)
```

### (a):The proportion of females who have had an acne problem
```{r}
### xs.nz[(!is.na(xs.nz[, "acne"]) & xs.nz[, "sex"] == "F" & xs.nz[, "acne"] == 1 : columns name = acne, "sex" equals "F", and "acne" equals 1.
### counting  for totall rows satisfy conditions above nrow(~)
### Calculating nrow(~) / nrow(~)
proportion_females_with_acne <- nrow(xs.nz[( xs.nz[, "sex"] == "F" & xs.nz[, "acne"] == 1),])/ nrow(xs.nz["acne"])

t1 <- xs.nz[( xs.nz[, "sex"] == "F" & xs.nz[, "acne"] == 1),]
table(is.na(t1[,"acne"]))
proportion_females_with_acne
print(paste0("Proportion of females who have an acne problem are ",proportion_females_with_acne * 100, "%"))
```
### (b):What is the age of the oldest Maori who has a cat and a dog?


```{r}
### (xs.nz[, "ethnicity"] == "Maori" & xs.nz[, "dog"] == 1 & xs.nz[, "cat"] == 1): expect return boolean array of index that satisfies requirement. 
### query rows that satisfies both conditions and match up columns' name: xs.nz[(xs.nz[, "ethnicity"] == "Maori" & xs.nz[, "dog"] == 1 & xs.nz[, "cat"] == 1), "age" ]
### To get rip off the NA figures so the result remains meaningful na.rm = TRUE
### select max figure from following condition max(~)
oldest_age <- max(xs.nz[(xs.nz[, "ethnicity"] == "Maori" & xs.nz[, "dog"] == 1 & xs.nz[, "cat"] == 1), "age" ], na.rm = T)
oldest_age
```
### (c):Among current smokers, what proportion drinks alcohol each week, on average? What about among nonsmokers?

```{r}
### X <- xs.nz[(!is.na(xs.nz[, "drinkweek"]) & xs.nz[, "smokenow"] == 1),]: expects return Boolean array that contains index of element that satisfy the requirement.
### nrow(X): count how many element satisfies the requirement
smoker_alocho <- nrow(xs.nz[(!is.na(xs.nz[, "drinkweek"]) & xs.nz[, "smokenow"] == 1),])/nrow(xs.nz["smokenow"])
!is.na("drinkweek")
### X <- xs.nz[!is.na(xs.nz[,"drinkweek"]) & xs.nz[, "smokenow"] == 0,]: expects return boolean array that contains index of element that satisfies the requirement 
smoker_non_alocho <- nrow(xs.nz[!is.na(xs.nz[,"drinkweek"]) & xs.nz[, "smokenow"] == 0,]) / nrow(xs.nz["smokenow"])

smoker_alocho
smoker_non_alocho
```

# Task 3: Write some very short R code (or R functions) to compute the following series or products. You must create each term to do the addition/multiplication. If you write a function, it should have an argument n which can be assumed to have good input. Obtain the answer for n = 64 for cases (a)–(d)

a:

```{r}
sum_series <- function(n) {
  if (length(n) != 1 || n < 0 || !is.finite(n) || n != floor(n) )
         stop("invalid n") # will not process either decimal number, or empty inputs
  
  if(n==0) return(0) # if n is 0
  
  # other condition 
  sum(1 / (1:(n-1) * 2:n))
}

# extreme case tests
#test1 <- sum_series(-99)
#test2 <- sum_series(0)
#test3 <- sum_series(0.3)
#test4 <- sum_series()

result_a <- sum_series(64)
result_a
```

b:

```{r}
prod_series <- function(n) {
  prod(
    sapply(1:n, 
           function(k) 
              {1 + (-1)^(k+1) / k})
    )
  }
result_b <- prod_series(64)
result_b
```

c:

```{r}
prod_series_c <- function(n) prod(sapply(1:n, function(k) 1 + 1 / (k * (k + 2))))
result_c <- prod_series_c(64)
result_c
```

d:

```{r}
sum_inf <- function(n, eps = 1e-8) {
  sum_val <- 0
  k <- 1
  term <- 1 / prod(k:(k+n))
  while (term > eps) {
    sum_val <- sum_val + term
    k <- k + 1
    term <- 1 / prod(k:(k+n))
  }
  sum_val
}
result_d <- sum_inf(64)
result_d
```

e:

```{r}
n_vals <- 1:100
limit_approx <- (n_vals^n_vals / factorial(n_vals))^(1/n_vals)
limit_approx
```
# 4： Solve the following short problems using R

a) random variable has a discrete Lindley distribution if its probability mass function is
f (x; θ) = (1 − e−θ)2 (1 + x) e−θx, x = 0, 1, 2, . . . , (1)
where θ > 0. Write a function ddislind(x, shape, log.arg = FALSE) for (1). That
is, it should work for vectors x and shape, and logical log.arg. If the latter is TRUE then
log f is returned.


```{r}
ddislind <- function(x, shape, log.arg = FALSE) {
  f_x <- (1 - exp(-shape))^2 * (1 + x) * exp(-shape * x)
  if (log.arg) return(log(f_x))
  f_x
}
ddislind(10, 10:10)
```

b)Use your function to give evidence that ∑∞
x=0 f (x; θ) = 1 is satisfied—a property that
should hold for any valid PMF

```{r}
theta <- 2
pmf_sum <- sum(ddislind(0:100, theta))
pmf_sum

```

# 5:Use R to solve the following problems 

a)f 2 ‘large’ earthquakes occur on average each year at a particular city, what is the prob-
ability at least 8 occur during a 5 year period?
```{r}
prob_earthquakes <- 1 - ppois(7, lambda = 2 * 5)
prob_earthquakes
```

b) new organization is proposed, called ASNEM, whose sole criterion is that members must
have an intelligence quotient (IQ) in the bottom 3% of the general population. Suppose
IQs are normally distributed with mean 100 and standard deviation 15. What is the cutoff
point for the society?
```{r}
cutoff <- qnorm(0.03, mean = 100, sd = 15)
cutoff
```
c)Somebody called Fred is willing to make as many attempts at getting his drivers licence
as needed until he gets it. He estimates the probability of success of each test is 0.2. What
is the probability of getting his drivers licence within 5 attempts?
```{r}
prob_license <- pgeom(4, prob = 0.2)
prob_license
```

# 6

a)Write R expressions (or, better yet, R functions) that evaluate the variance according to
the two formulas above. Given the set of data
`> x <- c(1.5, 17, 2.5, 12, 21.3)`
compute the variances of x, x+10, x+10^2, x+10^3, . . . , x+10^10. When do the results
start to differ noticeably? Comment.

```{r}
standard_variance <- function(x) {
  n <- length(x)
  mean_x <- mean(x)
  sum((x - mean_x)^2) / (n - 1)
}

desk_calculator_variance <- function(x) {
  n <- length(x)
  sum(x^2) / (n - 1) - sum(x)^2 / (n * (n - 1))
}


```


b) se var() on the same vectors of data. Comment on the results
```{r}
x <- c(1.5, 17, 2.5, 12, 21.3)
for (i in 0:10) {
  shifted_x <- x + 10^i
  var_standard <- standard_variance(shifted_x)
  var_desk <- desk_calculator_variance(shifted_x)
  cat("Shift:", 10^i, "Standard Variance:", var_standard, "Desk Variance:", var_desk, "\n")
}

```
