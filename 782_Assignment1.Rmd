---
title: "Assignment_1"
author: "Shuo Mao 437681258"
date: "2024-07-23"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Task 1:
## Re-create the following sequences using R without the use of c() and explicit values. Hint: making use of the help files will sometimes help a lot.

(a): 

`(i) [1] -4 4 -4 4 -3 3 -3 2 -2 1`

```{r}
{positive_numbers = rep(4:1, 4:1);#creating numbers
alternating_sequence = positive_numbers * rep(c(-1, 1),#using circle to re-assign their postie or negative sign to it
                                              length.out = length(positive_numbers))}
print(alternating_sequence)
```


`(ii) [1] 1 22 333 4444 55555 666666 7777777 88888888`


```{r}
# using function to create repeated number with no space, then adding space between each repeated numbers
formatted_sequence <- paste(sapply(1:8, function(x) paste(rep(x, x), collapse = ""))# will generate number such as: 1, 22, 333 ....
                            , collapse = " ") # combine those number and re-format it. 

# Print the formatted sequence
cat(formatted_sequence)
```


`(iii) [1] "z" "Y" "x" "W" "v" "U" "t" "S" "r" "Q" "p" "O" "n" "M" "l" "K" "j" "I" "h" "G" [21] "f" "E" "d" "C" "b" "A"`


```{r}

lowercase <- rev(letters)  # "z" to "a"
uppercase <- rev(LETTERS)  # "Z" to "A"

#combine uppercase and lowercase alternatively 
combined <- c(rbind(lowercase[seq(1, 26, 2)], uppercase[seq(2, 26, 2)]))

# Print the combined sequence
print(combined)
```


`(iv) [1] "1^1=1" "2^2=4" "3^3=27" "4^4=256" "5^5=3125" [6] "6^6=46656" "7^7=823543" "8^8=16777216"`



```{r}
# Calculate the power results
{exponents <- 1:8;results <- paste(exponents, "^", exponents, "=", exponents^exponents)}
print(results)
```


`(v) [1] "jan1" "feb2" "mar3" "apr4" "may5" "jun6" "jul7" "aug8" "sep9" "oct10" [11] "nov11" "dec12"`


```{r}
# Create the vector of month abbreviations and corresponding numbers, then Combine the month abbreviations with the numbers
{months <- tolower(month.abb);numbers <- 1:12;result <- paste(months, numbers, sep = "")}
# Print the result
print(result)
```



(b): find and write down six different ways to assign a variable x the value 8

1: using '=' 
```{r}
x = 8 
print(x)
```
2: using '->'
```{r}
8 -> x
print(x)
```

3: using '<-'
```{r}
x <- 8
print(x)
```

4: using assign function
```{r}
assign("x", 8)
print(x)
```

5: using list function 

```{r}
x <<- 8
print(x)
```

6: using c function 

```{r}
x <- c(9,8,1,4)[2]
print(x)

eval(x <- 8)
x
```
## (c) We know that ex = ∑∞ i=0 xi/i!. Approximate this by A(k; x) = ∑k i=0 xi/i! for finite k. Find the value k such that A(k; 1) does not differ by exp(1) on your machine. 


```{r}
# Compute Euler's number
e <- exp(1)

# Initialize variables
k <- 0
approximation <- 0
tolerance <- .Machine$double.eps *2 # Machine precision (default tolerance)

# Loop to find the smallest k
repeat {
  # Update the approximation of A(k; 1)
  approximation <- approximation + 1 / factorial(k)
  
  # Check if the approximation is within the tolerance
  if (abs(approximation - e) <= tolerance) {
    break
  }
  
  # Increment k
  k <- k + 1
}

# Output the result
cat(sprintf("The smallest k such that A(k; 1) approximates exp(1) within machine precision is: %d\n", k))

```

# Task 2:Consider the data frame xs.nz in VGAMdata. Based on this cross-sectional study, use R expressions (not your eyes or my eyes) to find the values below (and show the values only, nothing else). Don’t use any explicit loop or anything equivalent. Ignore (delete) any cases with NAs in the relevant variables. Your code should be elegant and readable, etc

```{r}
# install vgamdata if not exist
if (!requireNamespace("VGAMdata", quietly = TRUE)) {
    install.packages("VGAMdata")
}
library(VGAMdata)
#str(xs.nz)
xs.nz <- na.omit(xs.nz)
```

### (a):The proportion of females who have had an acne problem
```{r}
### @Desc: query index that sex columns equals "F" and acne columns equals "1"
(acne= nrow(xs.nz[( xs.nz[, "sex"] == "F" & xs.nz[, "acne"] == 1),])/ nrow(xs.nz["acne"]) * 100)
```
### (b):What is the age of the oldest Maori who has a cat and a dog?


```{r}
### @Desc: select column name that satisfy requirement ethnicity equals Maori, dog equals 1 and cat equals 1
(age <- max(xs.nz[(xs.nz[, "ethnicity"] == "Maori" & xs.nz[, "dog"] == 1 & xs.nz[, "cat"] == 1), "age" ], na.rm = T))
```
### (c):Among current smokers, what proportion drinks alcohol each week, on average? What about among nonsmokers?

```{r}

  
### @Desc: Query the "drinkweek" column for those who also satisfy the condition "smokenow" equals 1
(alcohol = nrow(xs.nz[(!is.na(xs.nz[, "drinkweek"]) & xs.nz[, "smokenow"] == 1),])/nrow(xs.nz["smokenow"])*100)


### @Desc: Query the "drinkweek" column for those who also satisfy the condition "smokenow" equals 0
(non_alcohol <- nrow(xs.nz[!is.na(xs.nz[,"drinkweek"]) & xs.nz[, "smokenow"] == 0,]) / nrow(xs.nz["smokenow"]) * 100 )

```

# Task 3: Write some very short R code (or R functions) to compute the following series or products. You must create each term to do the addition/multiplication. If you write a function, it should have an argument n which can be assumed to have good input. Obtain the answer for n = 64 for cases (a)–(d)

a:

```{r}
sum_series <- function(n) {
  ### @param: Denominator (n-1) * n
  ### @Return: result of math function sum(n) 1/(n-1)*n
  
  # condition that throw a warning to reminder user of range of vaild value
  if (length(n) != 1 || n < 0 || !is.finite(n) || n != floor(n)|| n==0)
         warning("invalid inputs") # will throw an error when process decimal numbers, empty inputs, negative number and zeros 
  
  if(n==0) {
    return(0) # if n is 0
  }
  
  # Actual math function
  sum(1 / (1:(n-1) * 2:n))
}

# extreme case tests
#(test1 <- sum_series(-99))
#(test2 <- sum_series(0))
#(test3 <- sum_series(0.3))
#(test4 <- sum_series())

# valid inputs test
#(test5 <- sum_series(12))
#(test6 <- sum_series(32))
(result_a <- sum_series(64))

```

b:

```{r}
product_series <- function(n){
   ### @param: Denominator n and power (n + 1)
   ### @return result of math function (1+ (-1)^n / n-1) * (1 + (-1)^(n+1)/n)
   if (length(n) != 1 || n < 0 || !is.finite(n) || n==0)
         warning("invalid inputs") # will throw an error when process  empty inputs, negative number and zeros 
  
  
  if(n ==0) return(1)
  product <- 1
  
  for (i in 1:n) {
    product <- product * (1 + ((-1)^(i+1)) / i)
  }
  
  product
}
# test case
#(test1 <- product_series(0))
#(test2 <- product_series(2))
#(test3 <- product_series())
#(test4 <- product_series(-99))
#(test5 <- product_series(0.9))

(result_b <- product_series(64))

```

c:

```{r}
product_series_c = function(n){
  ### @param: Denominator n
  ### @return: output of math equation (1 + 1/(n * n+2))
  if (length(n)  <1 ||  !is.finite(n) || n==0)
         warning("invalid inputs") # will throw an error when process  empty inputs,  and zeros 
  if(n == 0) return(1)
  product = 1
  for (i in 1:n) {
    product = product * (1 + 1 / (n* (n+2) ) )
  }
  product
}

# test case
#(test1 <- product_series_c(0))
(test2 <- product_series_c(-32))
#(test3 <- product_series())
#(test4 <- product_series(-99))
(test5 <- product_series(0.9))


(result_c <- product_series_c(64))
```

d:

```{r}
sum_inf <- function(n, eps = 1e-8) {
  ### @param: Denominator n:  k* (k+n-1) *  (k+n)
  ### @return: result of math function: sum 1/ k* (k+n-1) *  (k+n)
  if (length(n)  <1 ||  !is.finite(n) || n==0 || n != floor(n))
         warning("invalid inputs") # will throw an error when process  empty inputs,  and zeros 
  
  if(n!=floor(n)|| n == 0) return(NaN) # neither case will make term smaller than eps; hence will never stop
  if(n<0)return(0) # negative one of k will match with n hence, entire denominator will became to zero 
  sum_val <- 0
  k <- 1
  term <- 1 / (k * (k + 1) * (k + 2) * (k + n))# temp holder
  while (term > eps) {
    sum_val <- sum_val + term # sum function
    k <- k + 1 # accumulating from 1 to inf
    term <- 1 / prod(k:(k+n)) # 1/ k* (k+n-1) *  (k+n)
  }
  sum_val
}
# test case
#(test1 <- sum_inf(99))
#(test2 <- sum_inf(0.2))
#(test3 <- sum_inf(-32))
#(test4 <- sum_inf(0))

(result_d <- sum_inf(64))

```

e:

```{r}
compute_limit <- function(max_n = 100) {
  ### @param: time of iteration
  ### @return data frame that contains iteration times, value of math function and difference from exp(1)
  
  if (length(max_n)  <1 || max_n < 0 ||  !is.finite(max_n) || max_n==0 || max_n != floor(max_n))
         stop("invalid inputs") # will throw an error when process  empty inputs,  and zeros 
  
  results <- data.frame(n = integer(), value = numeric(), diff_from_e = numeric())# create data frame contain n, value, and difference
  e <- exp(1)
  
  for (n in 1:max_n) {
    value <- (n^n / factorial(n))^(1/n) # calculate function 
    diff_from_e <- abs(value - e)# calculate difference, the smaller the number closer to e
    results <- rbind(results, data.frame(n = n, value = value, diff_from_e = diff_from_e))# append result to data frame for better readability
  }
  results
}
# test 
#(compute_limit(-64))
#(compute_limit(0))
#(compute_limit())

(compute_limit(64))
```
# 4： Solve the following short problems using R

a) random variable has a discrete Lindley distribution if its probability mass function is
f (x; θ) = (1 − e−θ)2 (1 + x) e−θx, x = 0, 1, 2, . . . , (1)
where θ > 0. Write a function ddislind(x, shape, log.arg = FALSE) for (1). That
is, it should work for vectors x and shape, and logical log.arg. If the latter is TRUE then
log f is returned.


```{r}
ddislind <- function(x, shape, log.arg = FALSE) {
  ### @param: 
        # x:A vector of integer values at which the PMF needs to be evaluated.
        # shape: A vector of the same length as x containing the parameter θ.
        # log.arg: A logical argument that determines whether to return the logarithm of the PMF (log(f)).
  ### @return: if log.arg == true, should return PMF value 
  
  # Check if x and shape are vectors of the same length
  if (length(x) != length(shape)) {
    stop("x and shape must be vectors of the same length")
  }
  
  # Calculate the PMF for the discrete Lindley distribution
  pmf <- (1 - exp(-shape))^2 * (1 + x) * exp(-shape * x)
  
  # If log.arg is TRUE, return the logarithm of the PMF
  if (log.arg) {
    return(log(pmf))
  } else {
    return(pmf)
  }
}

x <- 0:5
shape <- rep(2, length(x))  # Example with theta = 2 for all x values
ddislind(x, shape)          # PMF values
ddislind(x, shape, log.arg = TRUE)  # Log PMF values
```

b)Use your function to give evidence that ∑∞
x=0 f (x; θ) = 1 is satisfied—a property that
should hold for any valid PMF

```{r}
verify_pmf_sum <- function(theta, tol = 1e-8, max_x = 1e3) {
  ### @param: element value of theta 
  ### @return: as expect sum_pmf should return 1
  
   # Create a sequence of x values from 0 to max_x
  x <- 0:max_x
  # Generate a vector of shape parameters, all set to the value of theta
  shape <- rep(theta, length(x))
  # Calculate the probability mass function (PMF) values for each x
  pmf_values <- ddislind(x, shape)
  sum_pmf <- sum(pmf_values)
  sum_pmf
}

theta <- 123
sum_pmf <- verify_pmf_sum(theta)
cat("Sum of PMF values:", sum_pmf)
```

# 5:Use R to solve the following problems 

a)If 2 ‘large’ earthquakes occur on average each year at a particular city, what is the prob-
ability at least 8 occur during a 5 year period?
```{r}
# λ for the 5-year period = 2 time earthquakes * 5 years
# x for probability of having 7 or fewer earthquakes
(prob_earthquakes <- 1 - ppois(7, lambda = 2 * 5))
```

b) new organization is proposed, called ASNEM, whose sole criterion is that members must
have an intelligence quotient (IQ) in the bottom 3% of the general population. Suppose
IQs are normally distributed with mean 100 and standard deviation 15. What is the cutoff
point for the society?
```{r}
# means to find  the 3rd percentile of the normal distribution with mean 100 and standard deviation 15.
(cutoff <- qnorm(x= 0.03, mean = 100, sd = 15))
```
c)Somebody called Fred is willing to make as many attempts at getting his drivers licence
as needed until he gets it. He estimates the probability of success of each test is 0.2. What
is the probability of getting his drivers licence within 5 attempts?
```{r}
#using geometric distribution for modeling the number of trials needed to get the first success, using 4 is because pgeom start form 0
(prob_license <- pgeom(4, prob = 0.2))
```

# 6

a)Write R expressions (or, better yet, R functions) that evaluate the variance according to
the two formulas above. Given the set of data
`> x <- c(1.5, 17, 2.5, 12, 21.3)`
compute the variances of x, x+10, x+10^2, x+10^3, . . . , x+10^10. When do the results
start to differ noticeably? Comment.

```{r}
standard_variance <- function(x) {
  ### @param: sample population x
  ### @return: standard variance of x
  
  n <- length(x) -1  # degree of freedom
  mean_x <- mean(x) # mean of x
  sum((x - mean_x)^2) / (n )
}

desk_calculator_variance <- function(x) {
  ### @param: sample population x
  ### @return:  variance of x
  n <- length(x)
  sum(x^2) / (n - 1) - sum(x)^2 / (n * (n - 1))
}
x <- c(1.5, 17, 2.5, 12, 21.3)


standard_variance(x)
desk_calculator_variance(x)

# Compute variances for x + 10^k
results <- sapply(1:10, function(k) {
  x_transformed <- x + 10^k
  var_standard_transformed <- standard_variance(x_transformed)
  var_desk_transformed <- desk_calculator_variance(x_transformed)
  return(c(var_standard_transformed, var_desk_transformed))
})

(results)
```

From the result that that we can discover that in the first 6th iteration that both standard_variance and desk_calculator_variance are produce same output, however start from 7th time iteration that two variance output start to have difference after 9th time iteration that desk_calculator_variance lost the ability to output correct result, whereas the standard_variance can keep its performance.

b) Use var() on the same vectors of data. Comment on the results
```{r}
# modify result function 
results <- sapply(1:10, function(k) {
  x_transformed <- x + 10^k
  var_standard_transformed <- standard_variance(x_transformed)
  var_desk_transformed <- desk_calculator_variance(x_transformed)
  var_2 <- var(x_transformed)
  return(c(var_standard_transformed, var_desk_transformed, var_2))
})

(results)
```
Observed from the output above that demonstrated their performance that standard_variance and var() are able to generate correct output after 10th iteration whereas desk_calculator_variance loss its accuracy after 5th iteration and loss ability to handle the data set after 9th iteration. 


```{r}
results <- sapply(1:20, function(k) {
  x_transformed <- x + 10^k
  var_standard_transformed <- standard_variance(x_transformed)
  var_desk_transformed <- desk_calculator_variance(x_transformed)
  var_2 <- var(x_transformed)
  return(c(var_standard_transformed, var_desk_transformed, var_2))
})

(results)

```

In addition, if we expend our iteration we can discover that both var() and standard_variance loss their accurate after 11st iteration, and loss ability to product output at 17th iteration.